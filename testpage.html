<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Mr. Smith (Perfect Sync)</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #ececec; margin: 0; display: flex; flex-direction: column; height: 100vh; }
        #chat { flex: 1; overflow-y: scroll; padding: 20px; display: flex; flex-direction: column; gap: 12px; }
        
        /* ë§í’ì„  ìŠ¤íƒ€ì¼ ì—…ê·¸ë ˆì´ë“œ */
        .msg { padding: 12px 16px; border-radius: 12px; max-width: 80%; line-height: 1.5; font-size: 16px; position: relative; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        
        .user { align-self: flex-end; background: #ffe812; color: #000; border-top-right-radius: 2px; }
        .user::after { content: 'Students'; position: absolute; top: -18px; right: 0; font-size: 11px; color: #888; }
        
        .ai { align-self: flex-start; background: #fff; border: 1px solid #ddd; border-top-left-radius: 2px; }
        .ai::after { content: 'Mr. Smith'; position: absolute; top: -18px; left: 0; font-size: 11px; color: #888; font-weight: bold; }

        /* ìƒíƒœ í‘œì‹œë°” */
        #controls { padding: 20px; background: white; text-align: center; border-top: 1px solid #ddd; }
        .btn { padding: 12px 24px; font-size: 16px; font-weight: bold; cursor: pointer; background: #333; color: white; border: none; border-radius: 8px; transition: background 0.2s; }
        .btn:hover { background: #555; }
        
        #status { font-weight: bold; margin-bottom: 12px; display: block; color: #555; font-size: 14px; }
        .listening { color: #e74c3c; animation: pulse 1.5s infinite; }
        .processing { color: #3498db; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>
    <div id="chat">
        <div class="msg ai">Next student! Don't waste my time. What do you want?</div>
    </div>
    <div id="controls">
        <span id="status">ì—°ê²° ëŒ€ê¸° ì¤‘...</span>
        <button class="btn" id="connBtn" onclick="init()">ğŸ”Œ ìƒë‹´ ì‹œì‘ (ì„œë²„ ì—°ê²°)</button>
        <p style="color:#666; font-size: 13px; margin-top: 10px;"><b>[Space]</b> ëˆ„ë¥´ê³  ë§í•˜ê¸° â†’ ë–¼ë©´ ì „ì†¡</p>
    </div>

    <script>
        let socket, audioCtx, processor, source, stream;
        let isRecording = false;
        let currentAiBubble = null; 
        let tempUserBubble = null; // ğŸ”¹ ì„ì‹œ ë‚´ ë§í’ì„  ì €ì¥ìš©

        function init() {
            socket = new WebSocket("ws://localhost:8000/ws/kim-secretary");
            
            socket.onopen = async () => {
                document.getElementById('status').innerText = "âœ… ì¤€ë¹„ ì™„ë£Œ";
                document.getElementById('connBtn').style.display = 'none';
                
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                source = audioCtx.createMediaStreamSource(stream);
                processor = audioCtx.createScriptProcessor(4096, 1, 1);
                
                source.connect(processor);
                processor.connect(audioCtx.destination);

                processor.onaudioprocess = (e) => {
                    if (!isRecording) return;
                    const inputData = e.inputBuffer.getChannelData(0);
                    const pcmData = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        const s = Math.max(-1, Math.min(1, inputData[i]));
                        pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }
                    let binary = '';
                    const bytes = new Uint8Array(pcmData.buffer);
                    for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
                    
                    socket.send(JSON.stringify({
                        type: "input_audio_buffer.append",
                        audio: window.btoa(binary)
                    }));
                };
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);

                if (data.type === 'response.audio.delta') {
                    playAudio(data.delta);
                }
                
                // ğŸ”¹ ë‚´ ì§„ì§œ ìë§‰ì´ ë„ì°©í–ˆì„ ë•Œ
                if (data.type === 'user_text') {
                    if (tempUserBubble) {
                        // ì•„ê¹Œ ë§Œë“¤ì–´ë‘” ì„ì‹œ ë§í’ì„ ì˜ ë‚´ìš©ì„ ì§„ì§œë¡œ êµì²´!
                        tempUserBubble.innerText = data.text;
                        tempUserBubble = null; // ì—­í•  ëë‚¬ìœ¼ë‹ˆ ì´ˆê¸°í™”
                    } else {
                        // ë§Œì•½ ì„ì‹œ ë§í’ì„ ì´ ì—†ë‹¤ë©´ ìƒˆë¡œ ë§Œë“¦ (í˜¹ì‹œ ëª¨ë¥¼ ì—ëŸ¬ ë°©ì§€)
                        appendBubble(data.text, 'user');
                    }
                }

                // AI ìŠ¤íŠ¸ë¦¬ë°
                if (data.type === 'ai_stream') {
                    if (!currentAiBubble) {
                        currentAiBubble = appendBubble('', 'ai');
                    }
                    currentAiBubble.innerText += data.text;
                    scrollToBottom();
                }

                if (data.type === 'ai_done') {
                    currentAiBubble = null; 
                }
            };
        }

        function appendBubble(text, type) {
            const div = document.createElement('div');
            div.className = `msg ${type}`;
            div.innerText = text;
            document.getElementById('chat').appendChild(div);
            scrollToBottom();
            return div;
        }

        function scrollToBottom() {
            const chat = document.getElementById('chat');
            chat.scrollTop = chat.scrollHeight;
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !isRecording) {
                if(socket) socket.send(JSON.stringify({type: "input_audio_buffer.clear"}));
                isRecording = true;
                document.getElementById('status').innerText = "ğŸ™ï¸ ë“£ëŠ” ì¤‘...";
                document.getElementById('status').className = "listening";
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && isRecording) {
                isRecording = false;
                document.getElementById('status').innerText = "â³ ì²˜ë¦¬ ì¤‘...";
                document.getElementById('status').className = "processing";
                
                // ğŸ”¹ [í•µì‹¬] ìŠ¤í˜ì´ìŠ¤ë°” ë–¼ìë§ˆì '...' ë§í’ì„  ë¨¼ì € ìƒì„±!
                // AIê°€ ì•„ë¬´ë¦¬ ë¹¨ë¼ë„ ë‚´ ë§í’ì„ ì´ ë¬´ì¡°ê±´ ìœ„ì— ìƒê¹€.
                tempUserBubble = appendBubble("... (Thinking)", 'user');

                if(socket) {
                    socket.send(JSON.stringify({type: "input_audio_buffer.commit"}));
                    socket.send(JSON.stringify({type: "response.create"}));
                }
            }
        });

        let nextTime = 0;
        function playAudio(base64) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const binary = window.atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            const floats = new Float32Array(bytes.length / 2);
            const view = new DataView(bytes.buffer);
            for (let i = 0; i < floats.length; i++) floats[i] = view.getInt16(i*2, true) / 32768;
            
            const buffer = audioCtx.createBuffer(1, floats.length, 24000);
            buffer.getChannelData(0).set(floats);
            const src = audioCtx.createBufferSource();
            src.buffer = buffer;
            src.connect(audioCtx.destination);
            
            if (nextTime < audioCtx.currentTime) nextTime = audioCtx.currentTime;
            src.start(nextTime);
            nextTime += buffer.duration;
        }
    </script>
</body>
</html>