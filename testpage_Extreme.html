<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Spartan Hell Mode ğŸ”¥</title>
    <style>
        /* (ìŠ¤íƒ€ì¼ì€ ê¸°ì¡´ê³¼ ë™ì¼) */
        body { font-family: 'Segoe UI', sans-serif; background: #222; color: #fff; margin: 0; display: flex; flex-direction: column; height: 100vh; }
        #chat { flex: 1; overflow-y: scroll; padding: 20px; display: flex; flex-direction: column; gap: 12px; }
        .msg { padding: 12px 16px; border-radius: 12px; max-width: 80%; line-height: 1.5; }
        .user { align-self: flex-end; background: #f1c40f; color: #000; }
        .ai { align-self: flex-start; background: #ecf0f1; color: #000; }
        #controls { padding: 20px; background: #333; text-align: center; }
        .listening { color: #e74c3c; animation: pulse 0.5s infinite; font-weight: bold; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
    </style>
</head>
<body>
    <div id="chat">
        <div class="msg ai">ğŸ‘¿ I don't have all day. Speak FAST or get out!</div>
    </div>
    <div id="controls">
        <span id="status">Ready</span>
        <button onclick="init()">ğŸ”¥ Start Hell Mode</button>
        <p>[Space]ë¥¼ ëˆ„ë¥´ê³  ë§í•˜ì„¸ìš”. <b>1ì´ˆë§Œ ë¨¸ë­‡ê±°ë ¤ë„ ì§¤ë¦½ë‹ˆë‹¤.</b></p>
    </div>

    <script>
        let socket, audioCtx, processor, source, stream, analyser;
        let isRecording = false;
        let silenceStart = 0; // ì¹¨ë¬µ ì‹œì‘ ì‹œê°„
        let silenceThreshold = 0.02; // ì¹¨ë¬µ ê¸°ì¤€ ë³¼ë¥¨ (0~1 ì‚¬ì´, ì¡ìŒ í™˜ê²½ì— ë”°ë¼ ì¡°ì ˆ í•„ìš”)
        let silenceLimit = 1500; // 1.5ì´ˆ ì´ìƒ ì¹¨ë¬µí•˜ë©´ ë°”ë¡œ ì»·!

        function init() {
            socket = new WebSocket("ws://localhost:8000/ws/kim-secretary");
            
            socket.onopen = async () => {
                document.getElementById('status').innerText = "ğŸ”¥ HELL MODE ACTIVATED";
                
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                source = audioCtx.createMediaStreamSource(stream);
                
                // ğŸ”Š ë³¼ë¥¨ ë¶„ì„ê¸° ì¶”ê°€
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);

                processor = audioCtx.createScriptProcessor(4096, 1, 1);
                source.connect(processor);
                processor.connect(audioCtx.destination);

                processor.onaudioprocess = (e) => {
                    if (!isRecording) return;
                    
                    // 1. ì˜¤ë””ì˜¤ ì „ì†¡
                    const inputData = e.inputBuffer.getChannelData(0);
                    const pcmData = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        pcmData[i] = Math.max(-1, Math.min(1, inputData[i])) * 0x7FFF;
                    }
                    let binary = '';
                    const bytes = new Uint8Array(pcmData.buffer);
                    for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
                    socket.send(JSON.stringify({type: "input_audio_buffer.append", audio: window.btoa(binary)}));

                    // 2. ğŸ”¥ ì¹¨ë¬µ ê°ì§€ ë¡œì§ (Hell Mode í•µì‹¬)
                    const dataArray = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteFrequencyData(dataArray);
                    
                    // í‰ê·  ë³¼ë¥¨ ê³„ì‚°
                    let sum = 0;
                    for(let i=0; i<dataArray.length; i++) sum += dataArray[i];
                    let average = sum / dataArray.length;
                    
                    // ë³¼ë¥¨ì´ ê¸°ì¤€ì¹˜ë³´ë‹¤ ë‚®ìœ¼ë©´ (ì¹¨ë¬µ)
                    if (average < 10) { // 10ì€ ì‹¤í—˜ê°’ (ì¡ìŒì— ë”°ë¼ ì¡°ì ˆ)
                        if (Date.now() - silenceStart > silenceLimit) {
                            // ğŸ’¥ ê°•ì œ ì¢…ë£Œ íŠ¸ë¦¬ê±° ë°œë™!
                            stopRecording(true); 
                        }
                    } else {
                        silenceStart = Date.now(); // ë§í•˜ê³  ìˆìœ¼ë©´ íƒ€ì´ë¨¸ ë¦¬ì…‹
                    }
                };
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'response.audio.delta') playAudio(data.delta);
                if (data.type === 'user_text') appendBubble(data.text, 'user');
                if (data.type === 'ai_stream') appendStreamBubble(data.text);
                if (data.type === 'ai_done') currentAiBubble = null;
            };
        }

        let currentAiBubble = null;
        function appendStreamBubble(text) {
            if (!currentAiBubble) {
                currentAiBubble = document.createElement('div');
                currentAiBubble.className = 'msg ai';
                currentAiBubble.innerText = 'ğŸ‘¿ ';
                document.getElementById('chat').appendChild(currentAiBubble);
            }
            currentAiBubble.innerText += text;
            document.getElementById('chat').scrollTop = document.getElementById('chat').scrollHeight;
        }

        function appendBubble(text, type) {
            const div = document.createElement('div');
            div.className = `msg ${type}`;
            div.innerText = type === 'user' ? `ğŸ˜° ${text}` : text;
            document.getElementById('chat').appendChild(div);
            document.getElementById('chat').scrollTop = document.getElementById('chat').scrollHeight;
        }

        function stopRecording(isForced = false) {
            if (!isRecording) return;
            isRecording = false;
            document.getElementById('status').innerText = isForced ? "ğŸ’¥ ì»·! (ë„ˆë¬´ ëŠë ¤)" : "â³ ì²˜ë¦¬ ì¤‘...";
            document.getElementById('status').className = "";

            if (socket) {
                if (isForced) {
                    // ê°•ì œ ì¢…ë£Œ ì‹ í˜¸ ì „ì†¡
                    socket.send(JSON.stringify({type: "hesitation_detected"}));
                } else {
                    // ì •ìƒ ì¢…ë£Œ
                    socket.send(JSON.stringify({type: "input_audio_buffer.commit"}));
                    socket.send(JSON.stringify({type: "response.create"}));
                }
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !isRecording) {
                isRecording = true;
                silenceStart = Date.now(); // íƒ€ì´ë¨¸ ì‹œì‘
                document.getElementById('status').innerText = "ğŸ™ï¸ SPEAK FAST!!";
                document.getElementById('status').className = "listening";
                if(socket) socket.send(JSON.stringify({type: "input_audio_buffer.clear"}));
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                stopRecording(false); // ì •ìƒì ìœ¼ë¡œ ë—ì„ ë•Œ
            }
        });

        // (playAudio í•¨ìˆ˜ëŠ” ê¸°ì¡´ê³¼ ë™ì¼)
        let nextTime = 0;
        function playAudio(base64) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const binary = window.atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            const floats = new Float32Array(bytes.length / 2);
            const view = new DataView(bytes.buffer);
            for (let i = 0; i < floats.length; i++) floats[i] = view.getInt16(i*2, true) / 32768;
            const buffer = audioCtx.createBuffer(1, floats.length, 24000);
            buffer.getChannelData(0).set(floats);
            const src = audioCtx.createBufferSource();
            src.buffer = buffer;
            src.connect(audioCtx.destination);
            if (nextTime < audioCtx.currentTime) nextTime = audioCtx.currentTime;
            src.start(nextTime);
            nextTime += buffer.duration;
        }
    </script>
</body>
</html>